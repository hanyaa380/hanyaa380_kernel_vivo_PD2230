#ifndef __POWER_SUPPLY_LITE_H
#define __POWER_SUPPLY_LITE_H

#include <linux/slab.h>
#include <linux/init.h>
#include <linux/sched.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/power_supply.h>

#define PSYL_IO_DEBUG			0

#define GETBIT(x,n)                     (x & (0x1<<n))
#define SETBIT(x,n)                     (x = (x | (0x1<<n)))
#define CLRBIT(x,n)                     (x = (x & ~(0x1<<n)))

#define GETARRAYNUM(array)		(sizeof(array)/sizeof(array[0]))
#define BETWEEN(val, min, max)		((val) >= (min) && (val) <= (max))

#define CHGIC_NAME_SIZE			64
#define DUMP_INFO_SIZE			1024
#define SPM_PERIOD			(5*60)

#ifdef CONFIG_VIVO_DUAL_CELL_CHARGE
#define CV_REFERENCE			8400
#else
#define CV_REFERENCE			4000
#endif



/************************************************************
 *
 *   [power_supply_lite define]
 *
 ***********************************************************/
enum vivo_power_supply_property {
	/* Properties of type `int' */
	/* vivo extensions of type for user node*/
	POWER_SUPPLY_PROP_DELTA = POWER_SUPPLY_PROP_SERIAL_NUMBER + 10,
	POWER_SUPPLY_PROP_RTC_UI_SOC,
	POWER_SUPPLY_PROP_ILIM_EN,
	POWER_SUPPLY_PROP_CHGIC_INIT,
	POWER_SUPPLY_PROP_USB_CONN1_TEMP,
	POWER_SUPPLY_PROP_DCHG_ENABLED,
	POWER_SUPPLY_PROP_BOOST_SW_VPH,

	POWER_SUPPLY_PROP_CHG_OPT,
	POWER_SUPPLY_PROP_DEBUG_INFO,

	POWER_SUPPLY_PROP_SETTING_USBIN_OVP,
	POWER_SUPPLY_PROP_DIRECT_CHG_BYPASS_TO_SWITCH_CHG,
	POWER_SUPPLY_PROP_DIRECT_CHG_BYPASS_TO_DIRECT_CHARGING,
	POWER_SUPPLY_PROP_FFC_TERMINATION_VOLTAGE,
	POWER_SUPPLY_PROP_FFC_TERMINATION_CURRENT,
	POWER_SUPPLY_PROP_FFC_CHARGE_FULL,

	/*switch*/
	POWER_SUPPLY_PROP_RERUN_APSD,
	POWER_SUPPLY_PROP_IS_FFC_RUNNING,

	/*ext fg*/
	POWER_SUPPLY_PROP_IS_ATBOOT,
	POWER_SUPPLY_PROP_POWER_OFF_CHARGING_MODE,
	POWER_SUPPLY_AI_CHARGE_STAE,

	POWER_SUPPLY_PROP_CALCULATION_TERMINATION_VOLTAGE,//Normal Charge Vbat Termination
	POWER_SUPPLY_PROP_DATA_ROLE,
	POWER_SUPPLY_PROP_REG_ADDRESS,
	POWER_SUPPLY_PROP_REG_DATA,
	POWER_SUPPLY_PROP_PKG_STATE,
	POWER_SUPPLY_PROP_FIXED_TEMP_KEY_VERIFY,
	POWER_SUPPLY_PROP_CC_STATE_TRIGGER,
	POWER_SUPPLY_PROP_ADAPTER_IBUS_MAX,
	POWER_SUPPLY_PROP_PLAT_USB_TYPE,
	POWER_SUPPLY_PROP_BC1P2_SUPPORT,
	POWER_SUPPLY_PROP_BOOSTCHG_SUPPORT,
	POWER_SUPPLY_PROP_MP2762_SUSP_MODE,
	POWER_SUPPLY_PROP_MP2762_INT_STATUS,
	POWER_SUPPLY_PROP_MP2762_ACOK_STATUS,
	POWER_SUPPLY_PROP_SW_CONV_FREQ,
	POWER_SUPPLY_PROP_FAM_EN,
	POWER_SUPPLY_PROP_CC_PLUGIN,
	POWER_SUPPLY_PROP_SOC_DISCHG,

	/************************wls local node start**************************/
	POWER_SUPPLY_PROP_WLS_LAUNCH_PAD_TX_VIN,//POWER_SUPPLY_PROP_WLS_TX_VIN
	POWER_SUPPLY_PROP_WLS_LAUNCH_PAD_TX_ADAPTER_TYPE,//POWER_SUPPLY_PROP_WLS_TX_ADAPTER_TYPE
	POWER_SUPPLY_PROP_WLS_LAUNCH_PAD_TX_VEND_ID,//POWER_SUPPLY_PROP_WLS_TX_VEND_ID
	POWER_SUPPLY_PROP_WLS_RX_VOUT,//POWER_SUPPLY_PROP_WIRELESS_RX_VOUT stm32
	POWER_SUPPLY_PROP_WLS_RX_ILIMIT,
	POWER_SUPPLY_PROP_WLS_RX_IOUT,//POWER_SUPPLY_PROP_WIRELESS_RX_IOUT stm32
	POWER_SUPPLY_PROP_WLS_RX_ENABLE,
	POWER_SUPPLY_PROP_WLS_RX_ENABLE_CONTINUE_TIME,
	POWER_SUPPLY_PROP_WLS_RX_AUTH,
	POWER_SUPPLY_PROP_WLS_RX_SLEEP_ENABLE,
	POWER_SUPPLY_PROP_WLS_RX_ENTER_FAST_CHARGING,
	POWER_SUPPLY_PROP_WLS_RX_DCHG_ENABLE,//POWER_SUPPLY_PROP_WIRELESS_DCHG_ENABLE stm32
	POWER_SUPPLY_PROP_WLS_TX_REVERSE_SWITCH,//POWER_SUPPLY_PROP_WIRELESS_WPC_REVERSE_SWITCH smblib & cms
	POWER_SUPPLY_PROP_WLS_TX_REVERSE_RESTART,
	POWER_SUPPLY_PROP_WLS_PMIC_VBUS_EN,//POWER_SUPPLY_PROP_WIRELESS_OTG_EN smb5
	POWER_SUPPLY_PROP_WLS_EXTERN_BOOST_ENABLE,//stm32 & sbm5
	POWER_SUPPLY_PROP_WLS_RX_CP_SWITCH,//POWER_SUPPLY_PROP_WIRELESS_SC_SWITCH stm32
	POWER_SUPPLY_PROP_WLS_TX_REVERSE_CP_SWITCH,
	POWER_SUPPLY_PROP_WLS_TX_REVERSE_VOUT_ON,
	POWER_SUPPLY_PROP_WLS_OTG_PRESENT,//smb5 & lib & stm32
	POWER_SUPPLY_PROP_WLS_RX_PRESENT,
	POWER_SUPPLY_PROP_WLS_TX_MODE,
	POWER_SUPPLY_PROP_WLS_RX_FW_DEBUG,
	POWER_SUPPLY_PROP_WLS_RX_ENCRY_AUTH_STATE,//POWER_SUPPLY_PROP_ENCRY_AUTH_STATE stm32
	POWER_SUPPLY_PROP_WLS_RX_CHG_STATUS,//POWER_SUPPLY_PROP_WPC_CHG_STATUS smb5
	POWER_SUPPLY_PROP_WLS_SHUTDOWN,//POWER_SUPPLY_PROP_WPC_SHUTDOWN stm32
	POWER_SUPPLY_PROP_WLS_RX_ICL_RESET,//POWER_SUPPLY_PROP_WIRELESS_ICL_RESET stm32
	POWER_SUPPLY_PROP_WLS_RX_FOD_MATCH_Q,
	POWER_SUPPLY_PROP_WLS_NOTIFY_PLUGIN_EVENT,
	POWER_SUPPLY_PROP_SET_FAN_SPEED,
	POWER_SUPPLY_PROP_FW_UPDATE_RESULT,
	POWER_SUPPLY_PROP_WLS_TRX_ENERGY_STATUS,
	POWER_SUPPLY_PROP_WLS_REVERSE_CHG_VBUS_VOLTAGE,
	POWER_SUPPLY_PROP_WLS_TX_CABLE_TYPE,
	POWER_SUPPLY_PROP_WLS_RX_DIE_TEMP,
	POWER_SUPPLY_PROP_WLS_TX_REVERSE_CHG_STATE,
	POWER_SUPPLY_PROP_WLS_TX_TO_TX_STATE,
	/***************************wls local node end****************************/

	/***************************wls user node start***************************/
	POWER_SUPPLY_PROP_WLS_DEBUG,
	POWER_SUPPLY_PROP_WLS_CHG_MODE,
	POWER_SUPPLY_PROP_WLS_RX_ONLINE,//POWER_SUPPLY_PROP_WPC_RX_ONLINE cms & stm32
	POWER_SUPPLY_PROP_WLS_RX_MODE,
	POWER_SUPPLY_PROP_WLS_RX_CHIP_EN,//smb5-lib stm32
	POWER_SUPPLY_PROP_WLS_RX_FW_ENABLE,
	POWER_SUPPLY_PROP_WLS_RX_FW_CRC,
	POWER_SUPPLY_PROP_WLS_TX_ONLINE,//POWER_SUPPLY_PROP_WPC_TX_ONLINE       sbmlib
	POWER_SUPPLY_PROP_WLS_TX_MODE_WORK,//must be check POWER_SUPPLY_PROP_WPC_TX_MODE
	POWER_SUPPLY_PROP_WLS_TX_VIN,
	POWER_SUPPLY_PROP_WLS_TX_IIN,
	POWER_SUPPLY_PROP_WLS_CURRENT_DELTA,//POWER_SUPPLY_PROP_WPC_CURRENT_DELTA stm32
	POWER_SUPPLY_PROP_WLS_PCLAMP_OVP,
	POWER_SUPPLY_PROP_WLS_REG_ADDRESS,//POWER_SUPPLY_PROP_WPC_REG_ADDRESS        stm32
	POWER_SUPPLY_PROP_WLS_REG_VALUE,//POWER_SUPPLY_PROP_WPC_REG_VALUE stm32
	POWER_SUPPLY_PROP_WLS_REG_LEN,//POWER_SUPPLY_PROP_WPC_REG_LEN stm32
	POWER_SUPPLY_PROP_WLS_REG_RW,//POWER_SUPPLY_PROP_WPC_REG_RW stm32
	POWER_SUPPLY_PROP_WLS_VIVO_CURRENT,//POWER_SUPPLY_PROP_WPC_VIVO_CURRENT cms & stm32
	POWER_SUPPLY_PROP_WLS_BPP_CURRENT,//POWER_SUPPLY_PROP_WPC_BPP_CURRENT stm32
	POWER_SUPPLY_PROP_WLS_FOD_SECTION,
	POWER_SUPPLY_PROP_WLS_AP_CMOS_CTL,//smb5 usb psy
	POWER_SUPPLY_PROP_WLS_MTP_READY,
	POWER_SUPPLY_PROP_WLS_MTP_CYCLE,
	POWER_SUPPLY_PROP_WLS_MTP_UPDATE_CYCLE,
	POWER_SUPPLY_PROP_WLS_MTP_TRIGGER,
	/**************************wls user node end*************************************/

	/************************wls local extern node start**************************/
	POWER_SUPPLY_PROP_WLS_PMIC_VBUS_EN_FAKE,
	POWER_SUPPLY_PROP_WLS_AP_CTRL_CMOS_SLEEP_EN,
	POWER_SUPPLY_PROP_WLS_AC_MISSING,
	POWER_SUPPLY_PROP_BC1P2_RESULT,
	POWER_SUPPLY_PROP_REG_DUMP,
	POWER_SUPPLY_PROP_WLS_POWER_PROFILE,
	POWER_SUPPLY_PROP_WLS_TX_PPS_INFO,
	POWER_SUPPLY_PROP_TRX_HW_RESTART,
	POWER_SUPPLY_PROP_WLS_HALL,
	/************************wls local extern node end**************************/
	/******da9313 fixed freq start*********/
	POWER_SUPPLY_PROP_GSM_LOCK_STATE,
	/******da9313 fixed freq end**********/
	POWER_SUPPLY_PROP_WLS_PROGRAM_FW_TEST_MODE,
	POWER_SUPPLY_PROP_WLS_PROGRAM_FW_TEST_MODE_RETRY_RESULT,
	POWER_SUPPLY_PROP_WLS_VFCP_TO_BUCK,
	POWER_SUPPLY_PROP_REVERSE_WLS_MODE,
	POWER_SUPPLY_PROP_HTCC_KEEP_UI,
	/************************wls local extern node end**************************/
	POWER_SUPPLY_PROP_PROTOCOL_POWER,
	POWER_SUPPLY_PROP_WLS_TX_FW_VER,
	POWER_SUPPLY_PROP_WLS_PMIC_VBUS_EN_STATUS,
	POWER_SUPPLY_PROP_WLC_THERM,
	POWER_SUPPLY_PROP_WLC_CON_THERM,
	POWER_SUPPLY_PROP_NBAT_CHGIC_TEMP,
	POWER_SUPPLY_PROP_BAT_BTB_M_TEMP,
	POWER_SUPPLY_PROP_BOARD_TEMP_STATE,

	/*vfcs*/
	POWER_SUPPLY_PROP_VFCS_IC_SUPPORT,
	POWER_SUPPLY_PROP_ID,
	POWER_SUPPLY_PROP_ADDRESS,
	POWER_SUPPLY_PROP_DATA,
	POWER_SUPPLY_PROP_ENABLE,
	POWER_SUPPLY_PROP_SWITCH_CLK,
	POWER_SUPPLY_PROP_I2C_EXCEP_STATE,
	POWER_SUPPLY_PROP_VBUS_STAT,
	POWER_SUPPLY_PROP_HW_INIT,
	POWER_SUPPLY_PROP_VBUS_VOLTAGE,
	POWER_SUPPLY_PROP_IBUS_CURRENT,
	POWER_SUPPLY_PROP_PROTOCOL_POWER_PPS_VBUS,
	POWER_SUPPLY_PROP_PROTOCOL_POWER_PPS_IBUS,
	POWER_SUPPLY_PROP_PROTOCOL_POWER_PPS_STATUS,
	POWER_SUPPLY_PROP_PROTOCOL_POWER_RET_STATUS,
	POWER_SUPPLY_PROP_PROTOCOL_POWER_PDO,
	POWER_SUPPLY_PROP_MAIN_BOARD_DCHG_IC_VBAT,
	POWER_SUPPLY_PROP_SLAVE_BOARD_DCHG_IC_VBAT,
	POWER_SUPPLY_PROP_DCHG_SUSPEND_PMI,
	POWER_SUPPLY_PROP_FAST_CHARGE_DRIVER,
	POWER_SUPPLY_PROP_PD_CABLE_ID,
	POWER_SUPPLY_PROP_STATE_MACHINE,
	POWER_SUPPLY_PROP_STAT_ERROR,

	/*vivo extensions of type for no user node end*/
	POWER_SUPPLY_PROP_VBAT_FROM_MASTER,
	POWER_SUPPLY_PROP_VBAT_FROM_SLAVE,
	POWER_SUPPLY_PROP_VBAT_FROM_PRIMARY,
	POWER_SUPPLY_PROP_TSHELL_TEMP,
	POWER_SUPPLY_PROP_BATNTC_TEMP,
	POWER_SUPPLY_PROP_MAX,
};

enum vivo_power_supply_usb_type {
	POWER_SUPPLY_TYPE_USB_PROP_DELTA = POWER_SUPPLY_TYPE_END,//12
	POWER_SUPPLY_TYPE_USB_HVDCP_3,		/* Efficient High Voltage DCP */
	POWER_SUPPLY_TYPE_USB_HVDCP_3P5,	/* Efficient High Voltage DCP */
	POWER_SUPPLY_TYPE_USB_PD_PPS,		/* PD Programmable Power Supply */
};

enum ADPT_TYPE {
	APPT_NORMAL,
	APPT_QC,
	APPT_PD,
	APPT_PPS,
	APPT_VFCP,
	APPT_UFCS,
	APPT_MAX,
};

enum direction_io {
	SET_IN = 0,
	GET_OUT = 1,
};

enum power_supply_lite_num {
	PSYL_NUM_UNKNOWN = 0,
	PSYL_MAIN,
	PSYL_BATTERY_ID,
	PSYL_BATTERY,
	PSYL_METER,
	PSYL_CHARGE,
	PSYL_CMS,
#define PSL_IS_READY(stat)		((stat & 0x7E) == 0x7E)
	PSYL_MCU,
	PSYL_FUELSUMMARY,
	PSYL_CHGIC_PRIMARY,
	PSYL_CHGIC_PARALLEL,
	PSYL_FG_EX,
	PSYL_USB,
	PSYL_AC,
	PSYL_WIRELESS,
	PSYL_NUM_AUTO,
};

enum power_supply_lite_status {
	STATUS_UNIQUE = 0,
	STATUS_PRIMARY,
	STATUS_PARALLEL,
	STATUS_MCU,
};

enum parallel_hw_supplier {
	HW_SUPPLIER_PARALLEL_UNKNOWN = 0,
	HW_SUPPLIER_PARALLEL_1,
	HW_SUPPLIER_PARALLEL_2,
	HW_SUPPLIER_PARALLEL_3,
	HW_SUPPLIER_PARALLEL_4,
	HW_SUPPLIER_PARALLEL_MAX,
};

struct power_supply_lite {
	const char *name;
	void *drv_data;
	int status;
	int dev_num;
	bool initialized;
	int (*ioctrl_property)(struct power_supply_lite *psyl,
			enum direction_io io, int psp,
			union power_supply_propval *val);
	struct list_head list;
};

extern void *power_supply_lite_get_drvdata(struct power_supply_lite *psyl);
extern struct power_supply_lite *get_power_supply_lite(const char *name, int dnum);
extern int power_supply_lite_register(struct power_supply_lite *psyl, int dnum);
extern int power_supply_lite_ioctrl_property(struct power_supply_lite *psyl,
		enum direction_io io, int psp, union power_supply_propval *val);
extern int power_supply_lite_change(enum direction_io io,
		int psp, union power_supply_propval *val);
extern int power_supply_lite_get_property(enum power_supply_lite_num psylnum,
		int psp, union power_supply_propval *val);
extern int power_supply_lite_set_property(enum power_supply_lite_num psylnum,
		int psp, union power_supply_propval *val);
extern bool power_supply_lite_is_ready(void);
extern bool power_supply_lite_detect(enum power_supply_lite_num psylnum);

#define POWER_SUPPLY_GET_PROPERTY(psy, psp, val)	(power_supply_get_property(psy, (enum power_supply_property)psp, val))
#define POWER_SUPPLY_SET_PROPERTY(psy, psp, val)	(power_supply_set_property(psy, (enum power_supply_property)psp, val))


/************************************************************
 *
 *   [enum lists]
 *
 ***********************************************************/
typedef enum {
	ROW = 0,
	COL,
} DIMENSION_ENUM;

typedef enum {
	INPUT_LIMIT = 0,
	LOWER_LIMIT,
	UPPER_LIMIT,
	LIMIT_INDEX_MAX,
} LIMIT_ENUM;

typedef enum {
	BATTERY_ID_NOT_LOADED = -1,
	BATTERY_UNKNOWN_SUPPLIER = 0,
	BATTERY_FIRST_SUPPLIER,
	BATTERY_SECOND_SUPPLIER,
	BATTERY_THIRD_SUPPLIER,
	BATTERY_FOURTH_SUPPLIER,
	BATTERY_FIFTH_SUPPLIER,
	BATTERY_SIXTH_SUPPLIER,
	BATTERY_SUPPLIER_MAX = BATTERY_SIXTH_SUPPLIER,
	BATTERY_DEFAULT_SUPPLIER = 100,
} BATTERY_VENDOR;

typedef enum {
	NORMAL_NO_WARNING = 0,
	CHARGER_VOLTAGE_HIGH,
	BATTERY_TEMPERATURE_HIGH,
	CURRENT_OVER_PROTECTION,
	BATTERY_VOLTAGE_HIGH,
	CHARGING_OVER_TIME,
	BATTERY_TEMPERATURE_LOW,
	BATTERY_ID_ERROR,
	BATTERY_TEMPERATURE_OFFSET,
	BATTERY_NOT_ORIGINAL,
	CHARGING_EXCEPTION,
	BATTERY_VOLTAGE_TEMPERATURE_HIGH,
	TEST_WARNING,
	CHARGE_USB_CONN_HEAT = 15,
	WARNING_NUMBER,
} WARNING_ENUM;

typedef enum {
	VBAT_AVG = 0,
	TBAT_AVG,
	IBAT_AVG,
	VBUS_AVG,
	AVG_NUMBER,
} AVG_ENUM;

typedef enum {
	AUTO_CHARGING = 0,
	NORMAL_CHARGINE,
	SINGLE_ENGIEN_CHARGINE,
	DUAL_ENGIEN_CHARGINE,
	FLASH_CHARGING,
} CHG_SCHEME_ENUM;

typedef enum {
	PMIC_DET_SOURCE = 0,
	CHGIC_DET_SOURCE,
} VBUS_DET_ENUM;

typedef enum {
	PWR_DET_READY = 0,
	PWR_DET_BUSY,
	PWR_DET_DONE,
} PWR_DET_ENUM;

typedef enum {
	BQ25970_SINGLE_DCHG = 1,
	NXP_PCA9486_DCHG,
	BQ25970_DUAL_DCHG,
	LN8000_DCHG,
} DCHG_VER;


#ifdef CONFIG_VCHG_VFCS_NEW_ARCH
typedef enum {
	APPD_TYPE,
	APPD_VOLT,
	APPD_CURR,
	APPD_MAX,
} _ADJUST_PROTOCOL_POWER_DATA_;

static const char * const _appt_str[] = {
	"APPT_NORMAL",
	"APPT_QC",
	"APPT_PD",
	"APPT_PPS",
	"APPT_VFCP",
	"APPT_UFCS",
	"APPT_MAX",
};

typedef enum {
	PP_RET_STATUS_UNKNOWN,
	PP_RET_STATUS_REQ_SUCCESS,
	PP_RET_STATUS_REQ_FAIL,
	PP_RET_STATUS_GET_PDO_SUCCESS,
	PP_RET_STATUS_GET_PDO_FAIL,
	PP_RET_STATUS_GET_STATUS_FAIL,
	PP_RET_STATUS_REQ_VOLT_NOT_SUPPORT,
	PP_RET_STATUS_REQ_CURR_NOT_SUPPORT,
	PP_RET_STATUS_NOT_SUPPORT_PPS,
	PP_RET_STATUS_GET_PPS_STS_SUCCESS,
	PP_RET_STATUS_GET_PPS_STS_FAIL,
} _PROTOCOL_POWER_RET_STATUS_;
#define NO_OF_PDOS_MAX  7

typedef enum _VIVO_FAST_CHARGE_DRIVER_ {
	VFC_DRIVER_UNKNOWN = 0,
	VFC_DRIVER_MCU = 1,
	VFC_DRIVER_VFCS = 2,
} _VIVO_FAST_CHARGE_DRIVER_;
#endif

typedef void (*CALL_BACK)(void);
extern int charge_psyl_register(struct power_supply_lite *psyl);
extern bool charge_psyl_has_mcu(void);
extern int get_average_value(AVG_ENUM type, int *buf, int size, int element);


struct vivo_wakeup_source {
	struct wakeup_source ws;
	bool held;
};
extern void vivo_wakeup_source_init(struct vivo_wakeup_source *vws, const char *name);
extern void vivo_wakeup_source_trash(struct vivo_wakeup_source *vws);
extern void vivo_wakeup_source_hold(struct vivo_wakeup_source *vws);
extern void vivo_wakeup_source_release(struct vivo_wakeup_source *vws);
extern bool vivo_wakeup_source_active(struct vivo_wakeup_source *vws);

#endif/* #ifndef __POWER_SUPPLY_LITE_H */
